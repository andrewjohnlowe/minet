\documentclass{article}
\usepackage{hyperref}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}

\begin{document}
\title{Inferring mutual information networks using the \Rpackage{minet} package}

%\VignetteIndexEntry{Inferring mutual information networks using the minet package}

\maketitle

\section{Introduction}

The \Rpackage{minet} package allows the user to infer mutual information 
networks from data. Each node in the network corresponds to a feature and 
the higher the weight of a link between two nodes, the higher the confidence in 
the existence of an interaction between the two features. 
In order to evaluate the interaction between two features, the mutual information 
is used as a dependence measure. The inference proceeds in two steps. 
First we compute the mutual information matrix ($MIM$), 
a square matrix where $MIM_{ij}$ is the mutual information between variables 
$X_i$ and $X_j$. In the second step, we apply an algorithm to the $MIM$ in order
to compute a score that will be used as the weight between the network nodes.
The following sections give examples on how to use the package in order to:
\begin{itemize}
      \item discretize data.
      \item estimate the mutual information matrix.
      \item infer a network.
      \item validate infered networks.
\end{itemize}

\section{Inference}
\subsection{Mutual Information Matrix Estimation}
<<>>=
library(minet)
data(syn.data)

#Data discretization
disc.method <- "equalwidth"
nbins <- sqrt(nrow(syn.data))
data <- disc(syn.data,disc.method,nbins)

#Mutual information estimation
estimator="empirical"
mim <- build.mim(data,estimator)
mim[1:5,1:5]
@
In the above code, the mutual information matrix is built using the function \Rfunction{build.mim}.
This function takes as argument the dataset and the mutual information estimator\footnote{Four estimators
(\Robject{"empirical"}, \Robject{"gaussian"}, \Robject{"millermadow"} and \Robject{"shrink"}) are implemented}. 
Depending on the estimator used, the data must contain discrete values. In order to discretize the data the function 
{\Rfunction{disc}} can be used. This function allows the user to choose between two binning algorithms\footnote{Equal frequencies and equal width
 algorithms}.
\subsection{Obtaining The Network}
Once the $MIM$ is computed, the network is obtained using one of the following functions : { \Rfunction{clr.net}},
{ \Rfunction{aracne.net}}, { \Rfunction{mr.net}}, which all take as argument the mutual information 
matrix : 

<<>>=
#Network Inference
net <- mr.net(mim)
net[1:5,1:5]
@
The returned value is the weighted adjacency matrix of the network.

\subsection{The \Rfunction{minet} function}
All the above code can be summarized with the \Rfunction{minet} function:
<<>>=
library(minet)
data(syn.data)
net <- minet(syn.data, 
             method="mrnet", 
             estimator="empirical", 
             disc.method="equalwidth", 
             nbins=sqrt(nrow(syn.data)))
net[1:5,1:5]
@
Note that in this case the returned object is the \emph{normalized} weighted adjacency matrix of the network (i.e. the values range from 0 to 1).

\section{Validation}
\subsection{Obtaining Confusion Matrices}
<<>>=
library(minet)
data(syn.data)
data(syn.net)
net <- minet(syn.data)

#Infered network validation
table <- validate(net, syn.net, steps=20)
table[1:10,]
@
In the above code, the { \Rfunction{validate}} function compares the infered network { \Robject{net}} to 
{\Robject{syn.net}}, the network underlying { \Robject{syn.data}}. Note that the true underlying network has to
be a boolean matrix. For each of the \Robject{steps} threshold values $T$, the edges whose weight are (strictly) 
below $T$ are eliminated. All the other edges will have a weight 1. Each of the \Robject{steps} resulting graph is compared to the 
true underlying network in order to get \Robject{steps} confusion matrices. The obtained confusion
matrices are appended to a data frame which will be the returned object of the \Rfunction{validate} function.

Note that the \Rfunction{validate} function distinguishes the following cases:
\begin{itemize}
      \item Both networks are oriented
      \item Both networks are unoriented
      \item One of the network is oriented and the other unoriented
\end{itemize}
In the third case, the oriented network will be considered unoriented.

\subsection{Processing Confusion Matrices}

<<>>=
library(minet)
data(syn.data)
data(syn.net)
net1 <- minet(syn.data,method="mrnet")
net2 <- minet(syn.data,method="clr")
#Infered network validation
table1 <- validate(net1, syn.net, steps=50)
table2 <- validate(net2, syn.net, steps=50)
@
Once the dataframes \Robject{table1} and \Robject{table2} are computed, we can use the function
\begin{itemize}
\item \Rfunction{pr(table)} to obtain precisions and recalls.
\item \Rfunction{rates(table)} to obtain true positive rates and false positive rates.
\item \Rfunction{fscores(table,beta)} to obtain $F_{\beta}-scores$.
\end{itemize}
The functions \Rfunction{show.pr} and \Rfunction{show.roc} allow the user to plot PR-curves and ROC-curves respectively. Both functions return 
the device associated to the plotting window used: 
<<>>=
#Precision recall curves
dev <- show.pr( table1, pch=2, type="b", col="green" )
show.pr( table2, device=dev, pch=1, type="b", col="blue")

#ROC curves
dev <- show.roc( table1, type="b", col="green" )
show.roc( table2,device=dev,type="b",col="blue" )
@
In the above code, the functions take as argument the dataframe \Robject{table} returned by \Rfunction{validate}. The user can use the returned device
to display several curves on the same plotting window.

\end{document}
